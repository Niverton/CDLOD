#pragma once

class Frustum;
class Planet;
struct PatchInstance;
#include "Patch.h"

enum TriNext { CULL, LEAF, SPLIT, SPLITCULL };


/**
  \brief  This is the represention of a node in the quadtree. 
          A node store a single triangle reprensent by 3 vertices.
          Other data is conserved in each node such as an information
          about the statement of the node.
          The node also has a pointer to this parent to allow deplacement
          from top to bottom and vice versa.
*/
struct Tri {
  Tri(glm::vec3 A, glm::vec3 B, glm::vec3 C, Tri *Parent, short Level)
      : a(A), b(B), c(C), parent(Parent), level(Level) {
  }

  Tri *parent = nullptr;

  Tri *c1 = nullptr;
  Tri *c2 = nullptr;
  Tri *c3 = nullptr;
  Tri *c4 = nullptr;

  TriNext state;

  short level;

  glm::vec3 a;
  glm::vec3 b;
  glm::vec3 c;
};

/**
  \brief  Class triangulator provide the mecanism of LOD.
          The planet is composed of an icosahedron with 12 faces which 
          represents the first node in the quadtree.
          Geometry of the planet is recusively generated by deviding each
          into 4 equilateral triangles. 
            /\
           /__\     Each triangle are a parent for 4 new more small node.
          /\  /\
         /__\/__\
*/

class Triangulator {
public:
  Triangulator(Planet *pPlanet);
  ~Triangulator();

  /**
    \Brief  Initialize the triangulator.
            Create the first 12 faces of the icasahedron, 
            Initialize the frustum and precompute culling.
            Afterward, geometry is recurively compute in terms of frustum and
            culling.
  */
  void Init();

  /**
    \brief  Update geometrie in terms of keyboard input event.
            The level of detail drawn can be forced. 
            Default level is 15.
  */
  bool Update();
 
  /**
    \brief  Calculate distanceLUT and calculate the distance between triangles 
            and camera position, based on FOV.
            For each triangle in icosahedron, call RecursiveTriangle.
  */
  void GenerateGeometry();

  bool IsFrustumLocked() {
    return m_LockFrustum;
  }
  Frustum *GetFrustum() {
    return m_pFrustum;
  }
  int GetVertexCount() {
    return m_Positions.size();
  }

private:
  friend class Planet;

  void Precalculate();

  /**
    \brief
    \param  a, first vertex of triangle
    \param  b, second vertex of triangle
    \param  c, third vertex of triangle
    \param  level, the level of the current triangle in the quadtree
    \param  frustrumCull  enable/disable the frustum culling
    \return Statment of the target node represented by triangle abc
              SPLIT or SPLITCULL if the target need to be split
              LEAF if the target is the last triangle
              CULL if the traget is outside of the frustum
  */
  TriNext SplitHeuristic(glm::vec3 &a, glm::vec3 &b, glm::vec3 &c, short level,
                         bool frustumCull);

  /**
    \brief  Check if triangle abc is drawable.
            If is inside the frustum, get the mid point of each edges and 
            recurcively compute the function with new vertex while the 
            subdivision is requiered. This test is based on camera distance and
            provide by the function SplitHeurisic.
            Otherwise push the triangle un the buffer.
    \param  a, first vertex of triangle
    \param  b, second vertex of triangle
    \param  c, third vertex of triangle
    \param  level, the level of the current triangle in the quadtree
    \param  frustrumCull  enable/disable the frustum culling
  */
  void RecursiveTriangle(glm::vec3 a, glm::vec3 b, glm::vec3 c, short level,
                         bool frustumCull);

  // Triangulation paramenters
  float m_AllowedTriPx = 300.f;
  int m_MaxLevel = 15;

  std::vector<Tri> m_Icosahedron;

  /**
    \brief  Lut used for store distance. Avoid recalculating distances.
            Use in SplitHeuristic.
  */
  std::vector<float> m_DistanceLUT;
  std::vector<float> m_TriLevelDotLUT;
  std::vector<float> m_HeightMultLUT;

  std::vector<Tri *> m_Leafs;

  Planet *m_pPlanet = nullptr;
  Frustum *m_pFrustum = nullptr;
  bool m_LockFrustum = false;

  std::vector<PatchInstance> m_Positions;
};
